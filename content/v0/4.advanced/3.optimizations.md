# Optimizations

**GM-I18n** aims to become a performance-oriented i18n system, and as such, it provides several optimizations to ensure that your game runs smoothly even with extensive localization.

## Automatic 

Some optimizations are applied automatically by the system, so you don't have to worry about them. These optimizations include:

### Flattened Message Keys

When you're adding message data to the system, **GM-I18n** always flattens the keys **automatically**. This means that if you have a message with a nested structure, it will be stored in a flat format, which can significantly speed up lookups and reduce memory usage.

For example, if you have a message like this in `en.json` locale file:

```json [en.json]
{
    "greeting": {
        "morning": "Good morning!",
        "evening": "Good evening!"
    }
}
```

It will be stored as:

```json [en.json]
{
    "greeting.morning": "Good morning!",
    "greeting.evening": "Good evening!"
}
```

The messages you add using `i18n_add_messages` function also follow this flattened structure. So, if you add a message like this:

```js [Create Event]
// assume you've  already initialized the i18n system

i18n_add_messages("en", {
    greeting : {
        morning: "Good morning!",
        evening: "Good evening!"
    }
});

// will be stored as:
// greeting.morning: "Good morning!",
// greeting.evening: "Good evening!"
```

::alert{type="info"}
This flattening process is done **automatically** by the system, so you don't need to worry about it when adding messages. You can continue to use nested structures in your code, and the system will handle the conversion for you.
::

---

### Hashed Message Keys

To further optimize performance, you can enable hashed message keys. This feature allows the system to use a hash of the message key instead of the full key string, which can significantly speed up lookups, especially in large projects with many messages.

To enable hashed message keys, you can set `hashed: true` option in the `i18n_create` function when initializing the i18n system.

```js [Create Event]
// Initialize the i18n system with hashed message keys
global.i18n = i18n_create("g.i18n", "en", [
    // array of locales to load
	new I18nLocaleInit("en", "English", "~/langs/en.json"),
	new I18nLocaleInit("id", "Bhs Indonesia", "~/langs/id.json"),
	new I18nLocaleInit("ja", "日本語", "~/langs/ja.json")
], {
    // this struct is used to configure the i18n options
    hashed: true            // enable hashed message keys
});
```

::alert{type="info"}
By default, hashed message keys are **disabled**, because they can make debugging more difficult, as the original message keys are not directly visible in the code. <br> <br>

Even so, if your project has a large number of messages, you're **recommended** to **enable** this feature to improve performance.
::

---

### Optimized Reference Update

If you're using the `i18n_create_ref_message()` function to create references to messages, you're actually optimizing the way you manage messages in your game. Because the **GM-I18n** system will only update all of the references in one go with `i18n_update_refs()` or `i18n_set_locale()` function, instead of updating each reference individually (or even worse, updating the message/reference individually every step in the game loop).

This means that if you change a message, you can simply call `i18n_update_refs()` or `i18n_set_locale()` to update all references at once, rather than having to update each reference individually. This can significantly reduce the overhead of updating messages in your game, especially if you have a lot of references in your code.

Moreover, if the reference you created using `i18n_create_ref_message()` or `i18n_create_ref_asset()` is not used anymore, the system will automatically remove it from the list of references, so you don't have to worry about memory leaks or performance issues caused by unused references.

::alert{type="info"}
This optimization is particularly useful in games with dynamic content, where messages may change frequently. By using references and updating them in bulk, you can ensure that your game remains responsive and efficient. <br> <br>

You don't need to worry about the performance impact of updating messages, as the system is designed to handle this efficiently.
::

::alert{type="success"}
:icon{name="hugeicons:checkmark-circle-03"} &nbsp; The `i18n_create_ref_*` functions are the recommended way to create references to messages and assets in **GM-I18n**. They are designed to be efficient and easy to use, allowing you to manage your localization data effectively without sacrificing performance.
::

---

### Chunk Loading

Let's say you have a large number of locales, and you want to load them in chunks, instead in one go, you can use the `time` option in the `i18n_create()` function to control how the locales are loaded.

This option allows you to specify an **interval** in seconds between loading each locale, which can help reduce the initial loading time of your game and improve performance.

Look at the following example:

```js [Create Event]
// Initialize the i18n system without chunk loading
global.i18n = i18n_create("g.i18n", "en", [                                // the `time` option is not set
    new I18nLocaleInit("en", "English", "~/langs/en.json"),                // so all locale files (langs/en.json, langs/id.json, langs/ja.json) will be loaded at once after 1 step of the game
    new I18nLocaleInit("id", "Bhs Indonesia", "~/langs/id.json"),          // it's the same if you set `time: 0`
    new I18nLocaleInit("ja", "日本語", "~/langs/ja.json")                   // may cause a performance issue if you have a lot of messages in these locale files, or you have a lot of locales to load
]);

// Initialize the i18n system with chunk loading
global.i18n = i18n_create("g.i18n", "en", [                                // the `time` option is set to 0.5 seconds
    new I18nLocaleInit("en", "English", "~/langs/en.json"),                // so the locales will be loaded in chunks, with 0.5 seconds interval between each locale
    new I18nLocaleInit("id", "Bhs Indonesia", "~/langs/id.json"),
    new I18nLocaleInit("ja", "日本語", "~/langs/ja.json")
], {
    time: 0.5           // load each locale in chunks with 0.5 seconds interval
});                     // load langs/en.json -> 0.5 seconds -> load langs/id.json -> 0.5 seconds -> load langs/ja.json

// you can split the locale files into multiple chunks
global.i18n = i18n_create("g.i18n", "en", [                                                 // the `time` option is set to 0.5 seconds
    new I18nLocaleInit("en", "English", ["~/langs/en1.json", "~/langs/en2.json"]),          // the splitted files will be loaded in chunks, with 0.5 seconds interval between each chunk
    new I18nLocaleInit("id", "Bhs Indonesia", "~/langs/id.json"),                           // it's useful if you have a lot of messages in the locale
    new I18nLocaleInit("ja", "日本語", "~/langs/ja.json")
], {
    time: 0.5           // load each locale in chunks with 0.5 seconds interval
});                     // load langs/en1.json -> 0.5 seconds -> load langs/en2.json -> 0.5 seconds -> load langs/id.json -> 0.5 seconds -> load langs/ja.json

```

---

## Manual

While the automatic optimizations provided by **GM-I18n** are generally sufficient for most projects, there are some additional manual optimizations you can apply to further enhance performance:

