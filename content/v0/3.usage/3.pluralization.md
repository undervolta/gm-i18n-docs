# Pluralization

Pluralization is a process of handling the plural form of a word. It's also known as `plural handling` or `plural form` in other localization system. It's also a powerful feature that makes any internationalization system complete!  

Let's say, you have a message that says "You have ``{count}`` apple". It's correct if you have only one apple. But if you have more than one apple, it should be "You have ``{count}`` apple**_s_**", right? That's where pluralization comes in handy!

---

## Static Pluralization

GM-I18n provides a simple pluralization feature that can handle the plural form of a word/phrase in the message. 

> Format: `form0 | form1 | ...` <br>
> Access: `<index>` or `{plural: <index>}` <br>
> Usage: `i18n_get_messages()`, `i18n_create_ref_message()`, `i18n_draw_message()`

For the static pluralization, the simplest way, you need to provide 2 forms of the word/phrase in the message. Generally, the first form is for singular, and the second form is for plural. And then you can pass the index of the form you want to use in the data.

::code-group
```js [Create Event]
// assume the system is initialized on global variable
// i18n_get_messages(key, [data], [locale], [i18n])
// i18n_create_ref_message(var_name, key, [data], [i18n])

// static messages, static pluralization
msg1 = i18n_get_messages("have_apple");             // "You don't have any apple | You have apple(s)", raw message

msg2 = [                                            // in an array
    i18n_get_messages("have_apple", 0)              // "You don't have any apple", 0 = directly use the first form
];  

msg3 = {                                                        // in a struct
    my_msg : i18n_get_messages("have_apple", 1, "id");          // "Kamu punya apel", 1 = directly use the second form
}; 

msg4 = i18n_get_messages("have_apple_cnt", {plural: 1});        // "I have 1 apple", {plural: 1} = use the second form through the `plural` key
msg5 = i18n_get_messages("have_apple_cnt", {                    // "I have 10 apples", {plural: 2} = use the third form, {count: 10} = replace the {count} placeholder
    plural : 2,                                                 // need to set the index value of the `plural` key manually
    count : 10                                                  // interpolate the {count} placeholder
});

// dynamic messages, static pluralization, no difference with static messages 
global.ref_msg1 = i18n_create_ref_message("global.ref_msg1", "have_apple");

global.ref_msg2 = [
    i18n_create_ref_message("g.ref_msg2.0", "have_apple", 0)
];

ref_msg3 = {
    my_msg : i18n_create_ref_message("ref_msg3.my_msg", "have_apple", 1, "id")
}

global.ref_msg4 = i18n_create_ref_message("global.ref_msg4", "have_apple_cnt", {plural: 1});
ref_msg5 = i18n_create_ref_message("ref_msg5", "have_apple_cnt", {
    plural: 2, 
    count: 10
});
```

```json [en.json]
{
    "have_apple": "You don't have any apple | You have apple(s)",
    "have_apple_cnt": "I don't have any apple | I have 1 apple | I have {count} apples"
}
```

```json [id.json]
{
    "have_apple": "Kamu tidak punya apel | Kamu punya apel",
    "have_apple_cnt": "Aku tidak punya apel | Aku punya 1 apel | Aku punya {count} apel"
}
```
::

::alert{type="info"}
You can use the `<index>` or `{plural: <index>}` to access the plural form. Both are valid. But it's recommended to use the `{plural: <index>}` because it's more readable and flexible. You can see the example in the next section. <br> <br>
::

::alert{type="warning"}
The plural form is **static**. So, if you change the value of the `plural` key after creating the message, it won't affect the plural form in the message. <br> <br>

You **can't** use the pluralization feature with the **indexed data**. You need to use the **named data** instead. See the [Interpolation](/v0/usage/interpolation) section for more information.
::

---

## Dynamic Pluralization

Dynamic pluralization use the same format as static pluralization, but the forms are **dynamic**. So, you can change the plural form in the message, even after creating the message.

> Format: `form0 | form1 | ...` <br>
> Access: `<index>` or `{plural: <index>}` or `{plural: <function>, plural_value: <value>}` <br>
> Usage: `i18n_get_messages()`, `i18n_create_ref_message()`, `i18n_draw_message()`

You can make your own pluralization rule in the `plural` key in the named data. The function will be called with the `plural_value` as the parameter, and then it will return the `index` of the plural form you want to use. It's great for complex pluralization rule!

### In Static Messages

This method is quite easy to implement the dynamic pluralization. You just need to **update** the message **every step**, and the pluralization will be updated automatically based on your pluralization rule.

> **Pros:**
> - Quite easy to implement.
> - No need to create the message reference.
> - Can be used in anywhere in the game, just like a static message.

> **Cons:**
> - Need to update the message every step (may cause performance issue).
> - Only support with direct pluralization (by passing `<index>` to the `data` parameter in the message).
> - Not suitable for complex pluralization rule.
> - No natural support for interpolated, linked, or nested message.

::code-group
```js [Create Event]
// assume the system is initialized on global variable

// the value to be passed to the pluralization function
apple_count = 0;
plural_index = 0;

// static messages in instance variable
msg1 = i18n_get_messages("have_apple_cnt", 0, "en");        // "I don't have any apple", will updated in Step Event

msg2 = [
    ""                                                      // empty string, will updated in Step Event
];

msg3 = {
    my_msg : i18n_get_messages("confirm", 0, "en")          // "No", will updated in Step Event
};

// static messages in global variable
global.my_msg = i18n_get_messages("have_apple_cnt", {
    plural: 0,                                              // "Aku tidak punya apel", will updated in Step Event
    count: apple_count
}, "id");   

global.my_arr = [
    i18n_get_messages("shop.buy", plural_index, "en")       // "Buy 1 {name}? | Buy {count} {name}{suffix}?", will updated in Step Event
];

global.my_struct = {
    my_msg : i18n_get_messages("confirm", 1, "en")          // "Yes", will updated in Step Event
};
```

```js [Step Event]
// update the message every step, so the pluralization will be updated automatically
// only applicable for static messages

msg1 = i18n_get_messages("have_apple_cnt",                  // simple pluralization rule
    (!apple_count ? 0 : (apple_count == 1 ? 1 : 2)),        // if apple_count is 0, use the first form (index 0). if apple_count is 1, use the second form (index 1). otherwise, use the third form (index 2)
"en");                                                      // will change to "I don't have any apple", "I have 1 apple", or "I have {count} apples" based on the apple_count value

msg2[0] = i18n_get_messages("shop.buy",
    (apple_count == 1 ? 0 : 1),                             // if apple_count is 1, use the first form. otherwise, use the second form
"en");                                                      // will change to "Buy 1 {name}?" or "Buy {count} {name}{suffix}?" based on the apple_count value

msg3.my_msg = i18n_get_messages("confirm",
    (apple_count >= 10 ? 0 : 1),                            // if apple_count is 10 or more, use the first form. otherwise, use the second form
"en");                                                      // will change to "No" or "Yes" based on the apple_count value

global.my_msg = i18n_get_messages("have_apple_cnt", {       // passing a struct as the data in event that update every step is DISCOURAGED!
    plural: (apple_count == 0 ? 0 : 1),                     // if apple_count is 0, use the first form. otherwise, use the second form
    count: apple_count                                      // interpolate the {count} placeholder
}, "id");                                                   // will change to "Aku tidak punya apel" or "Aku punya {count} apel" (interpolated) based on the apple_count value

global.my_arr[0] = i18n_get_messages("shop.buy", plural_index, "en");

global.my_struct.my_msg = i18n_get_messages("confirm",
    (apple_count >= 10 ? 0 : 1),
"en");
```

```js [Key Pressed - Up]
// increase the apple count
apple_count++;
```

```js [Key Pressed - Down]
// decrease the apple count
apple_count--;
```

```json [en.json]
{
    "have_apple_cnt": "I don't have any apple | I have 1 apple | I have {count} apples",
    "confirm": "No | Yes",
    "shop": {
        "template_1": "Your {resc} is",
        "buy": "Buy 1 {name}? | Buy {count} {name}{suffix}?",
        "confirm": "[[shop.template_1]]n't enough to buy {name} | [[shop.template_1]] enough to buy 1 {name} | [[shop.template_1]] enough to buy {count} {name}{suffix}"
    }
}
```

```json [id.json]
{
    "have_apple_cnt": "Aku tidak punya apel | Aku punya {count} apel",
    "confirm": "Tidak | Ya",
    "shop": {
        "template_1": "{resc} kamu",
        "buy": "Beli 1 {name}? | Beli {count} {name}?",
        "confirm": "[[shop.template_1]] tidak cukup untuk membeli {name} | [[shop.template_1]] cukup untuk membeli {count} {name}"
    }

}
```
::

::alert{type="info"}
The pluralization function (ternary operator in the example above) is called every time you update the message. So, it's better to make the function as simple as possible to avoid performance issue. <br> <br>

You can also store a value in a variable (such as `plural_index`), and then pass the variable to the `data` parameter.
::

::alert{type="warning"}
The static pluralization is not suitable for complex pluralization rule. Each language has its own pluralization rule, and it's impossible to cover all of them with a simple function.
::

### Using Direct Drawing

This method is the simplest and quickest way to implement the dynamic pluralization. You just need to pass the **plural index** (or a simple function that return the index) and the **key message** to the `i18n_draw_message()` function.

> **Pros:**
> - Super easy and quick to implement. Good choice if you only need to draw the message.
> - No need to create the message reference, not even create a variable for storing the message.
> - Can draw a static or dynamic message, with static or dynamic pluralization.

> **Cons:**
> - Only used for drawing the message. The `Draw Event` or `Draw GUI Event` is the only place you can use this method.
> - May cause a **performance issue** if you have a lot of message keys in that locale (like, 1000+ keys in a locale).
> - Only support with direct pluralization (by passing `<index>` to the `data` parameter in the message).
> - Not suitable for complex pluralization rule.
> - No natural support for interpolated, linked, or nested message.

::code-group
```js [Create Event]
// assume the system is initialized on global variable

// the value to be passed to the pluralization function
apple_count = 0;
plural_index = 0;
```

```js [Draw Event]
// i18n_draw_message(x, y, text, [data], [locale], [i18n])

// static message and pluralization
i18n_draw_message(100, 50, "@:have_apple_cnt", 0, "en");        // "I don't have any apple", will always use the first form (index 0)

// static message and dynamic pluralization
i18n_draw_message(100, 50, "@:confirm", plural_index, "id");    // "Tidak" if plural_index is 0, or "Ya" if plural_index is 1

i18n_draw_message(100, 50, "@:have_apple_cnt",
    (!apple_count ? 0 : (apple_count == 1 ? 1 : 2)),            // "I don't have any apple" if apple_count is 0, "I have 1 apple" if apple_count is 1, "I have {count} apples" otherwise (not interpolated)
"en");

i18n_draw_message(100, 50, "@:have_apple_cnt", {                // passing a struct as the data in event that update every step is DISCOURAGED!
    plural: (apple_count == 0 ? 0 : 1),                         // "Aku tidak punya apel" if apple_count is 0, "Aku punya {count} apel" otherwise (interpolated)
    count: apple_count
}, "id");

// dynamic message and pluralization
i18n_draw_message(100, 50, "@:confirm", (plural_index == 1));   // "No" / "Tidak" if plural_index is 0, or "Yes" / "Ya" if plural_index is 1

i18n_draw_message(100, 50, "@:shop.buy", 
    (apple_count == 1 ? 0 : 1)                                  // if apple_count is 1, use the first form. otherwise, use the second form
);

i18n_draw_message(100, 50, "@:have_apple_cnt", 
    (i18n_get_locale() == "en"                                  // a bit complex pluralization rule
        ? (!apple_count ? 0 : (apple_count == 1 ? 1 : 2))       // rule for en locale: "I don't have any apple" if apple_count is 0, "I have 1 apple" if apple_count is 1, "I have {count} apples" otherwise (not interpolated)
        : (apple_count >= 1))                                   // rule for other locale (id): "Aku punya {count} apel" if apple_count is 1 or more (not interpolated)
);
```

```js [Key Pressed - Up]
// increase the apple count
apple_count++;
```

```js [Key Pressed - Down]
// decrease the apple count
apple_count--;
```

```json [en.json]
{
    "have_apple_cnt": "I don't have any apple | I have 1 apple | I have {count} apples",
    "confirm": "No | Yes",
    "shop": {
        "template_1": "Your {resc} is",
        "buy": "Buy 1 {name}? | Buy {count} {name}{suffix}?",
        "confirm": "[[shop.template_1]]n't enough to buy {name} | [[shop.template_1]] enough to buy 1 {name} | [[shop.template_1]] enough to buy {count} {name}{suffix}"
    }
}
```

```json [id.json]
{
    "have_apple_cnt": "Aku tidak punya apel | Aku punya {count} apel",
    "confirm": "Tidak | Ya",
    "shop": {
        "template_1": "{resc} kamu",
        "buy": "Beli 1 {name}? | Beli {count} {name}?",
        "confirm": "[[shop.template_1]] tidak cukup untuk membeli {name} | [[shop.template_1]] cukup untuk membeli {count} {name}"
    }

}
```
::

::alert{type="info"}
You can add `@:` prefix to the `text` parameter in the `i18n_draw_message()` function to use the message key instead of the actual text. It's useful if you want to use the same message key in different locale (so it become a dynamic message). See the example above. <br> <br>

The pluralization function (ternary operator in the example above) is called every time you draw the message. So, it's better to make the function as simple as possible to avoid performance issue. <br> <br>

You can also store a value in a variable (such as `plural_index`), and then pass the variable to the `data` parameter.
::

::alert{type="warning"}
The direct drawing is **not suitable** for complex pluralization rule. Each language has its own pluralization rule, and it's impossible to cover all of them with a simple function. <br> <br>

The dynamic message in this method come with a performance cost. GM-I18n system will lookup the message from the locale data every time you draw the message. So, use it wisely.
::

### Using Message Reference

This method is the most flexible and powerful way to implement the dynamic pluralization. It's recommended for you to implement the dynamic pluralization with this method.

> **Pros:**
> - A true dynamic message.
> - Really flexible and powerful to implement the dynamic pluralization.
> - Suitable for complex pluralization rule.
> - Can apply interpolation, linked message, and nested message.
> - Really fast performance. The message is only lookup once, and then it will be updated if the locale is changed.
> - For the pluralization, you don't need to call the update function every time you want to update the message. Just update the data (`plural_value`), and the message will be updated automatically.

> **Cons:**
> - Take more effort to implement.
> - The pluralization rule may be a bit complex if you want to support multiple locale.
> - You need to manage the message reference yourself (such as updating the data).

::code-group
```js [Create]
// assume the system is initialized on global variable

// the value to be passed to the pluralization function
apple_count = 0;

// static messages, dynamic pluralization
msg1 = i18n_get_messages("have_apple_cnt", 0, "en");        // "I don't have any apple", will updated in Step Event

// dynamic messages, dynamic pluralization
global.ref_msg1 = i18n_create_ref_message("global.ref_msg1", "have_apple_cnt", {
    plural: function(plural_value) {                                            // the function for complex pluralization rule
        if (i18n_get_locale() == "en") {                                        // en locale has 3 forms
            return !plural_value ? 0 : (plural_value == 1 ? 1 : 2);             // if plural_value is 0, use the first form (index 0). if plural_value is 1, use the second form (index 1). otherwise, use the third form (index 2)
        } else if (i18n_get_locale() == "id") {                                 // id locale has only 2 forms
            return !plural_value ? 0 : 1;                                       // if plural_value is 0, use the first form (index 0). otherwise, use the second form (index 1)
        }
    },
    plural_value: apple_count,                                                  // the value to be passed to the pluralization function
    count: apple_count                                                          // interpolate the {count} placeholder
});
```

```js [Key Pressed - Up]
// increase the apple count
apple_count++;

// i18n_update_plurals(var_name, plural_value, [update_refs], [i18n])
// update the plural value in the message reference
i18n_update_plurals("global.ref_msg1", apple_count, true);
```

```js [Key Pressed - Down]
// decrease the apple count
apple_count--;
```

```js [Key Pressed - Space]
// change the locale
// i18n_set_locale(code, [update_refs], [i18n])
i18n_set_locale((i18n_get_locale() == "en" ? "id" : "en"));     // a simple locale switcher
```

```json [en.json]
{
    "have_apple_cnt": "I don't have any apple | I have 1 apple | I have {count} apples",
    "confirm": "No | Yes",
    "shop": {
        "template_1": "Your {resc} is",
        "buy": "Buy 1 {name}? | Buy {count} {name}{suffix}?",
        "confirm": "[[shop.template_1]]n't enough to buy {name} | [[shop.template_1]] enough to buy 1 {name} | [[shop.template_1]] enough to buy {count} {name}{suffix}"
    }
}
```

```json [id.json]
{
    "have_apple_cnt": "Aku tidak punya apel | Aku punya {count} apel",
    "confirm": "Tidak | Ya",
    "shop": {
        "template_1": "{resc} kamu",
        "buy": "Beli 1 {name}? | Beli {count} {name}?",
        "confirm": "[[shop.template_1]] tidak cukup untuk membeli {name} | [[shop.template_1]] cukup untuk membeli {count} {name}"
    }

}
```
::

